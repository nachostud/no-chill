<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>No Chill</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: Arial, sans-serif;
    }
    .game-container { text-align: center; }
    canvas { border: 2px solid #00f; background: #000; }
    .score { color: #fff; font-size: 24px; margin-bottom: 10px; }
    .game-over { color: #ff0; font-size: 32px; margin-top: 10px; }
    .instructions { color: #fff; margin-top: 10px; font-size: 14px; }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="score">Score: <span id="score">0</span></div>
    <canvas id="gameCanvas" width="600" height="500"></canvas>
    <div class="instructions">Use WASD or Arrow Keys to move the cat!</div>
    <div id="gameOver" class="game-over" style="display: none;">Game Over! Press R to restart</div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const gameOverElement = document.getElementById('gameOver');
    // Game variables
    let score = 0;
    let gameRunning = true;
    let powerMode = false;
    let powerModeTimer = 0;

    // Grid setup
    const CELL_SIZE = 20;
    const COLS = 30; // 600/20
    const ROWS = 25; // 500/20

    // Simple, working maze: open with some walls and dots (2), plants (3)
    const maze = [
      // 30 cols each row, 25 rows
      // 0: empty, 1: wall, 2: dot, 3: plant (power pellet)
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,1],
      [1,2,2,2,1,3,2,1,2,1,2,1,1,1,1,1,1,1,1,2,1,3,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,2,1,2,2,2,2,2,2,2,2,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,1],
      [1,2,2,2,1,3,2,1,2,1,2,1,1,1,1,1,1,1,1,2,1,3,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,2,1,2,2,2,2,2,2,2,2,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,2,1,1,1,1,1,1,1,1,2,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,1,2,2,2,2,2,1],
      [1,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
      [1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ];

    // Save original maze for restart
    const originalMaze = maze.map(row => row.slice());

    // Cat position: start at open area
    const cat = {
      x: 1,
      y: 1,
      direction: {x: 0, y: 0},
      nextDirection: {x: 0, y: 0}
    };

    // One ghost for clarity
    const birds = [
      { x: 28, y: 1, direction: { x: -1, y: 0 }, color: '#ff0000', scared: false }
    ];

    // Input handling
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      if (e.key.toLowerCase() === 'r' && !gameRunning) restartGame();
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    function handleInput() {
      if (keys['w'] || keys['arrowup']) cat.nextDirection = { x: 0, y: -1 };
      else if (keys['s'] || keys['arrowdown']) cat.nextDirection = { x: 0, y: 1 };
      else if (keys['a'] || keys['arrowleft']) cat.nextDirection = { x: -1, y: 0 };
      else if (keys['d'] || keys['arrowright']) cat.nextDirection = { x: 1, y: 0 };
    }

    function canMoveTo(x, y) {
      if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
      return maze[y][x] !== 1;
    }

    function moveCat() {
      // Try to turn
      if (canMoveTo(cat.x + cat.nextDirection.x, cat.y + cat.nextDirection.y)) {
        cat.direction = cat.nextDirection;
      }
      // Move in current direction
      const newX = cat.x + cat.direction.x;
      const newY = cat.y + cat.direction.y;
      if (canMoveTo(newX, newY)) {
        cat.x = newX;
        cat.y = newY;
      }
    }

    function moveBirds() {
      for (let bird of birds) {
        let possibleDirs = [
          { x: 0, y: -1 }, { x: 0, y: 1 },
          { x: -1, y: 0 }, { x: 1, y: 0 }
        ];
        // Don't go backwards unless no other option
        possibleDirs = possibleDirs.filter(d =>
          !(d.x === -bird.direction.x && d.y === -bird.direction.y)
        );
        let bestDirs = possibleDirs.filter(d => canMoveTo(bird.x + d.x, bird.y + d.y));
        if (bestDirs.length === 0) bestDirs = [{ x: -bird.direction.x, y: -bird.direction.y }];
        // Ghosts move randomly
        let chosenDir = bestDirs[Math.floor(Math.random() * bestDirs.length)];
        bird.direction = chosenDir;
        bird.x += bird.direction.x;
        bird.y += bird.direction.y;
      }
    }

    function checkDotAndPlant() {
      if (maze[cat.y][cat.x] === 2) {
        maze[cat.y][cat.x] = 0;
        score += 10;
      } else if (maze[cat.y][cat.x] === 3) {
        maze[cat.y][cat.x] = 0;
        score += 50;
        powerMode = true;
        powerModeTimer = 300;
        for (let b of birds) b.scared = true;
      }
    }

    function checkCollisions() {
      for (let bird of birds) {
        if (cat.x === bird.x && cat.y === bird.y) {
          if (powerMode && bird.scared) {
            bird.x = 28; bird.y = 1;
            bird.scared = false;
            score += 200;
          } else if (!powerMode) {
            gameOver();
          }
        }
      }
    }

    function update() {
      if (!gameRunning) return;
      handleInput();
      moveCat();
      moveBirds();
      checkDotAndPlant();
      checkCollisions();
      if (powerMode) {
        powerModeTimer--;
        if (powerModeTimer <= 0) {
          powerMode = false;
          for (let b of birds) b.scared = false;
        }
      }
      scoreElement.textContent = score;
    }

    function drawMaze() {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          if (maze[y][x] === 1) {
            ctx.fillStyle = '#2222ff';
            ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          } else if (maze[y][x] === 2) {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (maze[y][x] === 3) {
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(x * CELL_SIZE + CELL_SIZE / 2, y * CELL_SIZE + CELL_SIZE / 2, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
    }

    function drawCat() {
      ctx.fillStyle = '#f5a623';
      ctx.beginPath();
      ctx.arc(cat.x * CELL_SIZE + CELL_SIZE / 2, cat.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 2 - 2, 0.25 * Math.PI, 1.75 * Math.PI);
      ctx.lineTo(cat.x * CELL_SIZE + CELL_SIZE / 2, cat.y * CELL_SIZE + CELL_SIZE / 2);
      ctx.fill();
      // Ears
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(cat.x * CELL_SIZE + CELL_SIZE / 2 - 6, cat.y * CELL_SIZE + CELL_SIZE / 2 - 6, 3, 0, Math.PI * 2);
      ctx.arc(cat.x * CELL_SIZE + CELL_SIZE / 2 + 6, cat.y * CELL_SIZE + CELL_SIZE / 2 - 6, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBirds() {
      for (let bird of birds) {
        ctx.fillStyle = bird.scared && powerMode ? '#444' : bird.color;
        ctx.beginPath();
        ctx.arc(bird.x * CELL_SIZE + CELL_SIZE / 2, bird.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 2 - 2, Math.PI, 0);
        ctx.lineTo(bird.x * CELL_SIZE + CELL_SIZE / 2 + CELL_SIZE / 2 - 2, bird.y * CELL_SIZE + CELL_SIZE / 2 + CELL_SIZE / 2 - 2);
        ctx.lineTo(bird.x * CELL_SIZE + CELL_SIZE / 2 - CELL_SIZE / 2 + 2, bird.y * CELL_SIZE + CELL_SIZE / 2 + CELL_SIZE / 2 - 2);
        ctx.closePath();
        ctx.fill();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMaze();
      drawCat();
      drawBirds();
    }

    function loop() {
      update();
      draw();
      if (gameRunning) requestAnimationFrame(loop);
    }

    function gameOver() {
      gameRunning = false;
      gameOverElement.style.display = 'block';
    }

    function restartGame() {
      // Reset maze dots/plants
      for (let y = 0; y < ROWS; y++)
        for (let x = 0; x < COLS; x++)
          maze[y][x] = originalMaze[y][x];

      cat.x = 1; cat.y = 1;
      cat.direction = { x: 0, y: 0 };
      cat.nextDirection = { x: 0, y: 0 };
      birds[0].x = 28; birds[0].y = 1;
      score = 0;
      powerMode = false;
      for (let b of birds) b.scared = false;
      gameRunning = true;
      gameOverElement.style.display = 'none';
      loop();
    }

    // Start game
    loop();
  </script>
</body>
</html>