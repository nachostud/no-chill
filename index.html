<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>No Chill</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: Arial, sans-serif;
    }
    .game-container {
      text-align: center;
    }
    canvas {
      border: 2px solid #00f;
      background: #000;
    }
    .score {
      color: #fff;
      font-size: 24px;
      margin-bottom: 10px;
    }
    .level {
      color: #0f0;
      font-size: 20px;
      margin-bottom: 10px;
    }
    .game-over {
      color: #ff0;
      font-size: 32px;
      margin-top: 10px;
    }
    .instructions {
      color: #fff;
      margin-top: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="level">Level: <span id="level">1</span></div>
    <div class="score">Score: <span id="score">0</span></div>
    <canvas id="gameCanvas" width="900" height="750"></canvas>
    <div class="instructions">Use WASD or Arrow Keys to move Oresia!</div>
    <div id="gameOver" class="game-over" style="display: none;">Game Over! Press R to restart</div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const gameOverElement = document.getElementById('gameOver');

    // Game variables
    let score = 0;
    let currentLevel = 1;
    let gameRunning = true;
    let powerMode = false;
    let powerModeTimer = 0;

    // Grid setup - 1.5x bigger
    const CELL_SIZE = 30; // Increased from 20
    const COLS = 30;
    const ROWS = 25;

    // Level 1 maze layout (fully connected)
    const maze1 = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,3,1,1,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,1,3,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1,1,1,0,0,0,0,1,1,1,2,1,1,2,1,1,1,1,2,1],
      [0,2,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,0],
      [1,2,1,1,1,1,2,1,1,2,1,0,0,0,0,0,0,0,0,1,2,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,2,2,2,2,2,1],
      [1,1,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
      [1,3,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,3,1],
      [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
      [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
      [1,3,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // Level 2 maze layout (different design)
    const maze2 = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,3,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,3,1],
      [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,2,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1],
      [0,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,0],
      [1,1,1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,2,1,1,1,1,1,1,2,0,0,2,1,1,1,1,1,1,2,1,1,1,1,2,1],
      [0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0],
      [1,2,1,1,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,1,1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1,1,1],
      [1,3,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,3,1],
      [1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,2,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,2,1,1,1,2,1,1,2,1,1,1,1,1,1,2,1,1,2,1,1,1,2,1,1,2,1],
      [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1],
      [1,3,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,3,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    let maze = [...maze1.map(row => [...row])]; // Current maze

    // Game objects with smooth movement
    const cat = {
      gridX: 14, gridY: 21,
      pixelX: 14 * CELL_SIZE, pixelY: 21 * CELL_SIZE,
      direction: { x: 0, y: 0 },
      nextDirection: { x: 0, y: 0 },
      speed: 0.11,
      moving: false
    };

    const birdStarts = [
      { gridX: 16, gridY: 10 },
      { gridX: 15, gridY: 10 },
      { gridX: 14, gridY: 10 },
      { gridX: 13, gridY: 10 }
    ];

    const birds = birdStarts.map((start, i) => ({
      gridX: start.gridX,
      gridY: start.gridY,
      pixelX: start.gridX * CELL_SIZE,
      pixelY: start.gridY * CELL_SIZE,
      direction: { x: i % 2 === 0 ? 1 : -1, y: 0 },
      color: ['#ff0000', '#ffb8ff', '#00ffff', '#ffb852'][i],
      scared: false,
      speed: 0.06,
      moveTimer: i * 30,
      home: { gridX: start.gridX, gridY: start.gridY }
    }));

    // Input handling
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      if (e.key.toLowerCase() === 'r' && !gameRunning) {
        restartGame();
      }
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    function handleInput() {
      let newDirection = { x: 0, y: 0 };
      if (keys['w'] || keys['arrowup']) {
        newDirection = { x: 0, y: -1 };
      } else if (keys['s'] || keys['arrowdown']) {
        newDirection = { x: 0, y: 1 };
      } else if (keys['a'] || keys['arrowleft']) {
        newDirection = { x: -1, y: 0 };
      } else if (keys['d'] || keys['arrowright']) {
        newDirection = { x: 1, y: 0 };
      }
      cat.nextDirection = newDirection;
    }

    function canMoveTo(x, y) {
      if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return true; // tunneling
      return maze[y][x] !== 1;
    }
    function isAlignedToGrid(obj) {
      return Math.abs(obj.pixelX - obj.gridX * CELL_SIZE) < 1 && 
             Math.abs(obj.pixelY - obj.gridY * CELL_SIZE) < 1;
    }

    function updateCat() {
      if (isAlignedToGrid(cat)) {
        cat.pixelX = cat.gridX * CELL_SIZE;
        cat.pixelY = cat.gridY * CELL_SIZE;

        const nextX = cat.gridX + cat.nextDirection.x;
        const nextY = cat.gridY + cat.nextDirection.y;

        if (canMoveTo(nextX, nextY)) {
          cat.direction = { ...cat.nextDirection };
        } else if (cat.nextDirection.x === 0 && cat.nextDirection.y === 0) {
          cat.direction = { x: 0, y: 0 };
        }

        if (maze[cat.gridY] && maze[cat.gridY][cat.gridX] === 2) {
          maze[cat.gridY][cat.gridX] = 0;
          score += 10;
          scoreElement.textContent = score;
        } else if (maze[cat.gridY] && maze[cat.gridY][cat.gridX] === 3) {
          maze[cat.gridY][cat.gridX] = 0;
          score += 50;
          scoreElement.textContent = score;
          activatePowerMode();
        }
      }
      if (cat.direction.x !== 0 || cat.direction.y !== 0) {
        const newPixelX = cat.pixelX + cat.direction.x * cat.speed * CELL_SIZE;
        const newPixelY = cat.pixelY + cat.direction.y * cat.speed * CELL_SIZE;

        const newGridX = Math.round(newPixelX / CELL_SIZE);
        const newGridY = Math.round(newPixelY / CELL_SIZE);

        if (newGridX < 0) {
          cat.pixelX = (COLS - 1) * CELL_SIZE;
          cat.gridX = COLS - 1;
          return;
        } else if (newGridX >= COLS) {
          cat.pixelX = 0;
          cat.gridX = 0;
          return;
        }

        if (canMoveTo(newGridX, newGridY)) {
          cat.pixelX = newPixelX;
          cat.pixelY = newPixelY;
          cat.gridX = Math.round(cat.pixelX / CELL_SIZE);
          cat.gridY = Math.round(cat.pixelY / CELL_SIZE);
        } else {
          cat.pixelX = cat.gridX * CELL_SIZE;
          cat.pixelY = cat.gridY * CELL_SIZE;
          cat.direction = { x: 0, y: 0 };
        }
      }
      if (checkWin()) {
        if (currentLevel === 1) {
          nextLevel();
        } else {
          gameRunning = false;
          gameOverElement.textContent = "You Win! Press R to restart";
          gameOverElement.style.display = "block";
        }
      }
    }

    function nextLevel() {
      currentLevel = 2;
      levelElement.textContent = currentLevel;
      maze = [...maze2.map(row => [...row])];

      cat.gridX = 14;
      cat.gridY = 22;
      cat.pixelX = cat.gridX * CELL_SIZE;
      cat.pixelY = cat.gridY * CELL_SIZE;
      cat.direction = { x: 0, y: 0 };
      cat.nextDirection = { x: 0, y: 0 };

      birds.forEach((bird, index) => {
        bird.speed = 0.08;
        bird.scared = false;
        bird.moveTimer = index * 30;
        bird.gridX = 14 + (index - 1.5);
        bird.gridY = 9;
        bird.pixelX = bird.gridX * CELL_SIZE;
        bird.pixelY = bird.gridY * CELL_SIZE;
        bird.direction = { x: (index % 2 === 0) ? 1 : -1, y: 0 };
      });

      powerMode = false;
      powerModeTimer = 0;
    }

    function activatePowerMode() {
      powerMode = true;
      powerModeTimer = 400;
      birds.forEach(bird => bird.scared = true);
    }

    function updateBirds() {
      birds.forEach((bird, index) => {
        bird.moveTimer++;

        if (isAlignedToGrid(bird) && bird.moveTimer % 60 === 0) {
          bird.pixelX = bird.gridX * CELL_SIZE;
          bird.pixelY = bird.gridY * CELL_SIZE;

          const directions = [
            { x: 0, y: -1 },
            { x: 0, y: 1 },
            { x: -1, y: 0 },
            { x: 1, y: 0 }
          ];

          if (bird.scared && powerMode) {
            const dx = cat.gridX - bird.gridX;
            const dy = cat.gridY - bird.gridY;

            if (Math.abs(dx) > Math.abs(dy)) {
              const testDirection = { x: dx > 0 ? -1 : 1, y: 0 };
              if (canMoveTo(bird.gridX + testDirection.x, bird.gridY + testDirection.y)) {
                bird.direction = testDirection;
              }
            } else {
              const testDirection = { x: 0, y: dy > 0 ? -1 : 1 };
              if (canMoveTo(bird.gridX + testDirection.x, bird.gridY + testDirection.y)) {
                bird.direction = testDirection;
              }
            }
          } else if (Math.random() < 0.3) {
            const validDirections = directions.filter(dir => {
              const testX = bird.gridX + dir.x;
              const testY = bird.gridY + dir.y;
              return canMoveTo(testX, testY);
            });

            if (validDirections.length > 0) {
              bird.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
            }
          }
        }

        const newPixelX = bird.pixelX + bird.direction.x * bird.speed * CELL_SIZE;
        const newPixelY = bird.pixelY + bird.direction.y * bird.speed * CELL_SIZE;

        const newGridX = Math.round(newPixelX / CELL_SIZE);
        const newGridY = Math.round(newPixelY / CELL_SIZE);

        if (newGridX < 0) {
          bird.pixelX = (COLS - 1) * CELL_SIZE;
          bird.gridX = COLS - 1;
        } else if (newGridX >= COLS) {
          bird.pixelX = 0;
          bird.gridX = 0;
        } else if (newGridY >= 0 && newGridY < ROWS && canMoveTo(newGridX, newGridY)) {
          bird.pixelX = newPixelX;
          bird.pixelY = newPixelY;
          bird.gridX = newGridX;
          bird.gridY = newGridY;
        } else if (newGridY >= 0 && newGridY < ROWS && !canMoveTo(newGridX, newGridY)) {
          bird.direction.x *= -1;
          bird.direction.y *= -1;
          bird.pixelX = bird.gridX * CELL_SIZE;
          bird.pixelY = bird.gridY * CELL_SIZE;
        } else {
          bird.pixelX = newPixelX;
          bird.gridX = Math.round(bird.pixelX / CELL_SIZE);
          if (bird.gridX < 0) bird.gridX = 0;
          if (bird.gridX >= COLS) bird.gridX = COLS - 1;
        }

        const distance = Math.sqrt(
          Math.pow(bird.pixelX - cat.pixelX, 2) + 
          Math.pow(bird.pixelY - cat.pixelY, 2)
        );

        if (distance < CELL_SIZE * 0.8) {
          if (powerMode && bird.scared) {
            score += 200;
            scoreElement.textContent = score;
            bird.gridX = Math.random() > 0.5 ? -1 : COLS;
            bird.pixelX = bird.gridX * CELL_SIZE;
            bird.gridY = Math.floor(Math.random() * (ROWS - 4)) + 2;
            bird.pixelY = bird.gridY * CELL_SIZE;
            bird.direction.x = bird.gridX < 0 ? 1 : -1;
            bird.direction.y = 0;
            bird.scared = false;
          } else {
            gameRunning = false;
            gameOverElement.style.display = "block";
          }
        }
      });
    }

    function updatePowerMode() {
      if (powerMode) {
        powerModeTimer--;
        if (powerModeTimer <= 0) {
          powerMode = false;
          birds.forEach(bird => bird.scared = false);
        }
      }
    }

    function checkWin() {
      for (let row of maze) {
        for (let cell of row) {
          if (cell === 2 || cell === 3) return false;
        }
      }
      return true;
    }

    // New function to draw the ponytail palm plant
    function drawPlant(x, y) {
      // Pot base
      ctx.fillStyle = '#8b4513';
      ctx.fillRect(x + 9, y + 27, 14, 6);
      ctx.fillStyle = '#5a2d0c';
      ctx.fillRect(x + 11, y + 27, 10, 6);
      // Bulb base of the plant above pot
      ctx.fillStyle = '#deb887';
      ctx.beginPath();
      ctx.ellipse(x + 16, y + 22, 7, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      // Trunk
      ctx.fillStyle = '#a0522d';
      ctx.fillRect(x + 14, y + 15, 4, 11);
      // Leaves: symmetrical curved leaves swooping upward then drooping, on both sides
      ctx.strokeStyle = '#228b22';
      ctx.lineWidth = 2;
      const startX = x + 16;
      const startY = y + 15;
      for (let i = -2; i <= 2; i++) {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.bezierCurveTo(
          startX + i * 4,
          startY - 10 + i * 6,
          startX + i * 6,
          startY + 4 + i * 6,
          startX + i * 8,
          startY + 12
        );
        ctx.stroke();
      }
    }

    function drawMaze() {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const cell = maze[y][x];
          const pixelX = x * CELL_SIZE;
          const pixelY = y * CELL_SIZE;
          if (cell === 1) {
            // Wall
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(pixelX, pixelY, CELL_SIZE, CELL_SIZE);
          } else if (cell === 2) {
            // Dot
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(pixelX + 12, pixelY + 12, 6, 6);
          } else if (cell === 3) {
            drawPlant(pixelX, pixelY);
          }
        }
      }
    }

    function drawCat() {
      const centerX = cat.pixelX + CELL_SIZE/2;
      const centerY = cat.pixelY + CELL_SIZE/2;

      ctx.fillStyle = '#808080';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 13, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#707070';
      ctx.beginPath();
      ctx.moveTo(centerX - 8, centerY - 8);
      ctx.lineTo(centerX - 14, centerY - 17);
      ctx.lineTo(centerX - 3, centerY - 14);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(centerX + 8, centerY - 8);
      ctx.lineTo(centerX + 14, centerY - 17);
      ctx.lineTo(centerX + 3, centerY - 14);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#ffb6c1';
      ctx.beginPath();
      ctx.moveTo(centerX - 7, centerY - 9);
      ctx.lineTo(centerX - 10, centerY - 14);
      ctx.lineTo(centerX - 4, centerY - 12);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(centerX + 7, centerY - 9);
      ctx.lineTo(centerX + 10, centerY - 14);
      ctx.lineTo(centerX + 4, centerY - 12);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#90ee90';
      ctx.beginPath();
      ctx.arc(centerX - 6, centerY - 3, 3.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(centerX + 6, centerY - 3, 3.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(centerX - 6, centerY - 3, 1.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(centerX + 6, centerY - 3, 1.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ffb6c1';
      ctx.beginPath();
      ctx.moveTo(centerX, centerY + 1);
      ctx.lineTo(centerX - 3, centerY + 4);
      ctx.lineTo(centerX + 3, centerY + 4);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY + 4);
      ctx.quadraticCurveTo(centerX - 4, centerY + 7, centerX - 7, centerY + 6);
      ctx.moveTo(centerX, centerY + 4);
      ctx.quadraticCurveTo(centerX + 4, centerY + 7, centerX + 7, centerY + 6);
      ctx.stroke();

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(centerX - 14, centerY);
      ctx.lineTo(centerX - 8, centerY - 1);
      ctx.moveTo(centerX - 14, centerY + 3);
      ctx.lineTo(centerX - 8, centerY + 1);
      ctx.moveTo(centerX + 14, centerY);
      ctx.lineTo(centerX + 8, centerY - 1);
      ctx.moveTo(centerX + 14, centerY + 3);
      ctx.lineTo(centerX + 8, centerY + 1);
      ctx.stroke();
    }

    function drawBirds() {
      birds.forEach(bird => {
        const centerX = bird.pixelX + CELL_SIZE/2;
        const centerY = bird.pixelY + CELL_SIZE/2;

        const facingLeft = bird.direction.x < 0;

        if (bird.scared && powerMode) {
          ctx.fillStyle = '#000080';
        } else {
          ctx.fillStyle = bird.color;
        }

        ctx.beginPath();
        ctx.ellipse(centerX, centerY, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(centerX + (facingLeft ? -6 : 6), centerY - 3, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = bird.scared && powerMode ? '#000040' : '#ffffff';
        ctx.beginPath();
        if (facingLeft) {
          ctx.moveTo(centerX + 8, centerY);
          ctx.lineTo(centerX + 14, centerY - 3);
          ctx.lineTo(centerX + 14, centerY + 3);
        } else {
          ctx.moveTo(centerX - 8, centerY);
          ctx.lineTo(centerX - 14, centerY - 3);
          ctx.lineTo(centerX - 14, centerY + 3);
        }
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = bird.scared && powerMode ? '#000040' : '#dddddd';
        ctx.beginPath();
        ctx.ellipse(centerX, centerY + 2, 6, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ffa500';
        ctx.beginPath();
        if (facingLeft) {
          ctx.moveTo(centerX - 11, centerY - 3);
          ctx.lineTo(centerX - 15, centerY - 2);
          ctx.lineTo(centerX - 11, centerY - 1);
        } else {
          ctx.moveTo(centerX + 11, centerY - 3);
          ctx.lineTo(centerX + 15, centerY - 2);
          ctx.lineTo(centerX + 11, centerY - 1);
        }
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(centerX + (facingLeft ? -8 : 4), centerY - 5, 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#ffa500';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX - 2, centerY + 6);
        ctx.lineTo(centerX - 2, centerY + 10);
        ctx.moveTo(centerX + 2, centerY + 6);
        ctx.lineTo(centerX + 2, centerY + 10);
        ctx.stroke();
      });
    }

    function render() {
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawMaze();
      drawCat();
      drawBirds();

      if (powerMode) {
        ctx.fillStyle = `rgba(255, 255, 0, ${Math.sin(Date.now() * 0.01) * 0.3 + 0.3})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function gameLoop() {
      if (gameRunning) {
        handleInput();
        updateCat();
        updateBirds();
        updatePowerMode();
      }
      render();
      setTimeout(gameLoop, 1000 / 20);
    }

    function restartGame() {
      score = 0;
      currentLevel = 1;
      gameRunning = true;
      powerMode = false;
      powerModeTimer = 0;
      scoreElement.textContent = score;
      levelElement.textContent = currentLevel;
      gameOverElement.style.display = "none";

      maze = [...maze1.map(row => [...row])];

      cat.gridX = 14;
      cat.gridY = 21;
      cat.pixelX = cat.gridX * CELL_SIZE;
      cat.pixelY = cat.gridY * CELL_SIZE;
      cat.direction = { x: 0, y: 0 };
      cat.nextDirection = { x: 0, y: 0 };

      birds.forEach((bird, index) => {
        bird.scared = false;
        bird.speed = 0.06;
        bird.moveTimer = index * 30;

        bird.gridX = 13 + index;
        bird.gridY = 9;
        bird.pixelX = bird.gridX * CELL_SIZE;
        bird.pixelY = bird.gridY * CELL_SIZE;
        bird.direction = { x: (index % 2 === 0) ? 1 : -1, y: 0 };
      });
    }

    window.addEventListener('load', () => {
      console.log('Game starting...');
      gameLoop();
    });

    gameLoop();
  </script>
</body>
</html>
